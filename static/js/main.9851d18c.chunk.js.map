{"version":3,"sources":["AsyncVideos.tsx","ui/Button.tsx","ui/Messages.tsx","Store.tsx","Api.tsx","StaticFileLoader.tsx","VideosReadyDev.tsx","ApiUpTest.tsx","ui/LabelledInput.tsx","ui/LabelledSelect.tsx","Config.tsx","DevUi.tsx","VideoPermissions.tsx","VideoRecorder.tsx","ui/VideoStreamPreview.tsx","UserUi.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["AsyncVideos","start","middle","end","canvasRef","useRef","useState","videos","setVideos","size","width","videoWidth","height","videoHeight","currentVideoIndex","setCurrentVideoIndex","useEffect","a","blob","loadVideo","effect","useAnimationFrame","undefined","currentVideo","context","current","getContext","drawImage","pauseVideo","Error","length","onended","video","currentTime","paused","ended","readyState","console","log","play","pause","then","style","ref","videoBlob","Promise","resolve","reject","document","createElement","src","URL","createObjectURL","load","onloadeddata","onerror","error","frameRate","callback","requestRef","previousTimeRef","animate","useCallback","time","deltaTime","interval","setInterval","requestAnimationFrame","cancelAnimationFrame","clearInterval","Button","forwardRef","props","className","children","ErrorMessage","reason","PromptMessage","text","SuccessMessage","NeutralMessage","initialState","audioStream","videoStream","recordings","fakedRecording","fakedRecordingPromise","staticFiles","isPlaybackReady","config","recordingDuration","apiUrl","window","location","href","slice","webcamScale","store","create","set","get","setAudioStream","closeStreams","getTracks","forEach","track","addEventListener","setVideoStream","maybeAudio","maybeVideo","stop","setVideoRecording","recording","setStaticFiles","setFakedRecording","setFakedRecordingPromise","videoPromise","setPlaybackReadiness","isReady","resetState","useStore","createStoreHook","Api","audioSource","state","destinationVideo","resultVideo","uiState","setUiState","sendToApi","formData","FormData","append","toFixed","fakedVideoPromise","fetch","method","body","mode","response","includes","onClick","StaticVideoLoader","isAlreadyLoaded","loadAudio","warn","path","loadVideos","event","audio","oncanplaythrough","VideosReadyDev","maybeStaticVideos","maybeFakeRecordingPromise","controller","AbortController","signal","fetchStatusHandler","status","statusText","ApiUpTest","testApi","abort","LabelledInput","label","LabelledSelect","options","map","index","value","Config","name","type","min","max","onChange","getState","parseInt","target","setState","DevUi","isDevUiShowing","setDevUiShowing","buttonRef","noTranslation","menuTranslation","setMenuTranslation","transform","maybeBottom","getBoundingClientRect","bottom","innerHeight","VideoPermissions","isVideoStreamOn","getStreams","getVideoStream","navigator","mediaDevices","getUserMedia","facingMode","stream","VideoRecorder","duration","timeRemaining","setTimeRemaining","isRecording","setIsRecording","videoRecorder","useMemo","getVideoRecorder","timeout","setTimeout","url","videoUrl","clearTimeout","mediaRecorder","MediaRecorder","mimeType","videoChunks","push","data","Blob","VideoStreamPreview","srcObject","autoPlay","UserUi","isVideoPermissionGranted","App","startVideo","endVideo","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9851d18c.chunk.js","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\ntype Props = {\n  start: HTMLVideoElement;\n  middle: Promise<Blob>;\n  end: HTMLVideoElement;\n};\n\nconst isVideoPlaying = (video: HTMLVideoElement) =>\n  !!(video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2);\n\nexport const AsyncVideos = ({ start, middle, end }: Props): React.ReactElement => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [videos, setVideos] = useState<\n    [HTMLVideoElement, Promise<HTMLVideoElement>, HTMLVideoElement] | undefined\n  >();\n\n  const size = {\n    width: start.videoWidth,\n    height: start.videoHeight,\n  };\n\n  const [currentVideoIndex, setCurrentVideoIndex] = useState<number>(0);\n\n  useEffect(() => {\n    const effect = async () => {\n      const blob = await middle;\n      return loadVideo(blob);\n    };\n\n    setVideos([start, effect(), end]);\n  }, [end, middle, start]);\n\n  useAnimationFrame(60, async () => {\n    if (videos === undefined) return;\n\n    const currentVideo = await videos[currentVideoIndex];\n    const context = canvasRef.current?.getContext('2d');\n    if (currentVideo === undefined) return;\n    if (context === undefined || context === null) return;\n\n    context.drawImage(currentVideo, 0, 0, size.width, size.height);\n  });\n\n  useEffect(() => {\n    if (videos === undefined) return;\n\n    const effect = async () => {\n      const currentVideo = await videos[currentVideoIndex];\n      if (currentVideo === undefined)\n        throw new Error(\n          `currentVideoIndex out of range. Got ${currentVideoIndex}, expected between 0 and ${videos.length}`,\n        );\n      currentVideo.onended = () => setCurrentVideoIndex((currentVideoIndex + 1) % videos.length);\n      if (!isVideoPlaying(currentVideo)) {\n        console.log(`playing video ${currentVideoIndex}`);\n        currentVideo.play();\n      }\n\n      return () => {\n        currentVideo.pause();\n      };\n    };\n\n    const pauseVideo = effect();\n\n    return () => {\n      pauseVideo.then((pause) => pause?.());\n    };\n  }, [currentVideoIndex, videos]);\n\n  return (\n    <canvas\n      style={{ width: '100%' }}\n      ref={canvasRef}\n      width={size.width}\n      height={size.height}\n    ></canvas>\n  );\n};\n\nasync function loadVideo(videoBlob: Blob) {\n  return new Promise<HTMLVideoElement>((resolve, reject) => {\n    const video = document.createElement('video');\n    video.src = URL.createObjectURL(videoBlob);\n    video.load();\n    video.onloadeddata = () => resolve(video);\n    video.onerror = (error) => reject(error);\n  });\n}\n\nexport const useAnimationFrame = (\n  frameRate: number,\n  callback: (deltaTime: number) => void,\n): void => {\n  const requestRef = useRef<number>();\n  const previousTimeRef = useRef<number>();\n\n  const animate = useCallback(\n    (time: number) => {\n      if (previousTimeRef.current !== undefined) {\n        const deltaTime = time - previousTimeRef.current;\n        callback(deltaTime);\n      }\n      previousTimeRef.current = time;\n    },\n    [callback],\n  );\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      requestRef.current = requestAnimationFrame(animate);\n    }, 1000 / frameRate);\n    return () => {\n      requestRef.current && cancelAnimationFrame(requestRef.current);\n      interval && clearInterval(interval);\n    };\n  }, [animate, frameRate]);\n};\n","import { forwardRef } from 'react';\n\nimport './Button.css';\n\nexport const Button = forwardRef<HTMLButtonElement, React.ButtonHTMLAttributes<HTMLButtonElement>>(\n  (props, ref) => {\n    return (\n      <button ref={ref} className=\"Button\" {...props}>\n        {props.children}\n      </button>\n    );\n  },\n);\n","import './Messages.css';\n\nexport const ErrorMessage = ({ reason }: { reason: string }): React.ReactElement => {\n  return (\n    <div className=\"Message ErrorMessage\">\n      <span>Error: {reason}</span>\n    </div>\n  );\n};\n\nexport const PromptMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message PromptMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n\nexport const SuccessMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message SuccessMessage\">\n      <span>Success: {text}</span>\n    </div>\n  );\n};\n\nexport const NeutralMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message NeutralMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n","import create from 'zustand/vanilla';\nimport createStoreHook from 'zustand';\n\ntype Recording = {\n  blob: Blob;\n  url: string;\n};\n\ninterface Files {\n  start: HTMLVideoElement;\n  middle: HTMLAudioElement;\n  end: HTMLVideoElement;\n}\n\ntype State = {\n  audioStream: MediaStream | undefined;\n  videoStream: MediaStream | undefined;\n  staticFiles: Files | undefined;\n  recordings: { video?: Recording; audio?: Recording };\n  fakedRecording: Blob | undefined;\n  fakedRecordingPromise: Promise<Blob> | undefined;\n  isPlaybackReady: boolean;\n  config: {\n    recordingDuration: number;\n    apiUrl: string;\n    webcamScale: number;\n  };\n  setVideoStream: (videoStream: MediaStream) => void;\n  setAudioStream: (audioStream: MediaStream) => void;\n  closeStreams: () => void;\n  setVideoRecording: (recording: Recording) => void;\n  setStaticFiles: ({ start, middle, end }: Files) => void;\n  setFakedRecording: (video: Blob) => void;\n  setFakedRecordingPromise: (videoPromise: Promise<Blob>) => void;\n  setPlaybackReadiness: (isReady: boolean) => void;\n  resetState: () => void;\n};\n\ntype CallbackFunctionVariadic = (...args: never[]) => void;\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends CallbackFunctionVariadic ? never : K;\n}[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\nconst apiUrl =\n  window.location.href[window.location.href.length - 1] === '/'\n    ? window.location.href.slice(0, -1)\n    : window.location.href;\nconst initialState: NonFunctionProperties<State> = {\n  audioStream: undefined,\n  videoStream: undefined,\n  recordings: {},\n  fakedRecording: undefined,\n  fakedRecordingPromise: undefined,\n  staticFiles: undefined,\n  isPlaybackReady: false,\n  config: { recordingDuration: 10, apiUrl, webcamScale: 2 },\n};\n\nexport const store = create<State>((set, get) => ({\n  ...initialState,\n\n  setAudioStream: (audioStream) => {\n    get().closeStreams();\n\n    audioStream.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    set({ audioStream });\n  },\n  setVideoStream: (videoStream) => {\n    get().closeStreams();\n\n    videoStream.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    set({ videoStream });\n  },\n  closeStreams: () => {\n    const maybeAudio = get().audioStream;\n    const maybeVideo = get().videoStream;\n\n    if (maybeAudio) {\n      maybeAudio.getTracks().forEach((track) => {\n        track.stop();\n      });\n    }\n\n    if (maybeVideo) {\n      maybeVideo.getTracks().forEach((track) => {\n        track.stop();\n      });\n    }\n\n    set({ audioStream: undefined, videoStream: undefined });\n  },\n\n  setVideoRecording: (recording) => {\n    set({ recordings: { video: recording } });\n  },\n  setStaticFiles: ({ start, middle, end }) => {\n    set({ staticFiles: { start, middle, end } });\n  },\n  setFakedRecording: (video) => {\n    set({ fakedRecording: video });\n  },\n\n  setFakedRecordingPromise: (videoPromise) => {\n    set({ fakedRecordingPromise: videoPromise });\n  },\n\n  setPlaybackReadiness: (isReady: boolean) => set({ isPlaybackReady: isReady }),\n  resetState: () => {\n    const config = { ...get().config };\n    set({ ...initialState, config: { ...config } });\n  },\n}));\n\nexport const useStore = createStoreHook(store);\n","import React, { useEffect, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { SuccessMessage, ErrorMessage, NeutralMessage, PromptMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const Api = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const audioSource = useStore((state) => state.staticFiles?.middle);\n  const destinationVideo = useStore((state) => state.recordings?.video);\n  const resultVideo = useStore((state) => state.fakedRecording);\n  const webcamScale = useStore((state) => state.config.webcamScale);\n\n  const setFakedRecording = useStore((state) => state.setFakedRecording);\n  const setFakedRecordingPromise = useStore((state) => state.setFakedRecordingPromise);\n\n  const [uiState, setUiState] = useState<\n    | 'awaitingAudioSource'\n    | 'awaitingDestinationVideo'\n    | 'prompt'\n    | 'awaitingResult'\n    | 'success'\n    | 'errorApi'\n    | 'errorSources'\n  >(\n    audioSource === undefined\n      ? 'awaitingAudioSource'\n      : destinationVideo === undefined\n      ? 'awaitingDestinationVideo'\n      : !!resultVideo\n      ? 'success'\n      : 'prompt',\n  );\n\n  useEffect(() => {\n    const uiState =\n      audioSource === undefined\n        ? 'awaitingAudioSource'\n        : destinationVideo === undefined\n        ? 'awaitingDestinationVideo'\n        : !!resultVideo\n        ? 'success'\n        : 'prompt';\n\n    setUiState(uiState);\n  }, [audioSource, destinationVideo, resultVideo]);\n\n  const sendToApi = async () => {\n    if (!audioSource || !destinationVideo) {\n      console.error(\n        `Not all sources are ready. source: ${audioSource}, destination: ${destinationVideo})`,\n      );\n      setUiState('errorSources');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('image', destinationVideo.blob);\n    // formData.append('sound', audioSource);\n    formData.append('webcamScale', webcamScale.toFixed(0));\n\n    const fakedVideoPromise = new Promise<Blob>(async (resolve, reject) => {\n      try {\n        setUiState('awaitingResult');\n        const response = await fetch(apiUrl + '/three_videos_demo', {\n          method: 'POST',\n          body: formData,\n          mode: 'cors',\n        });\n\n        const video = await response.blob();\n        setUiState('success');\n        setFakedRecording(video);\n        resolve(video);\n      } catch (error) {\n        setUiState('errorApi');\n        console.error(error);\n        reject(error);\n      }\n    });\n\n    setFakedRecordingPromise(fakedVideoPromise);\n  };\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'awaitingAudioSource' && <NeutralMessage text=\"Awaiting audio source\" />}\n      {uiState === 'awaitingDestinationVideo' && (\n        <NeutralMessage text=\"Awaiting destination video\" />\n      )}\n      {uiState === 'prompt' && <PromptMessage text=\"Source and Destination ready to be faked\" />}\n      {!uiState.includes('awaiting') && <Button onClick={sendToApi}>Send to API</Button>}\n      {uiState === 'awaitingResult' && <NeutralMessage text=\"Waiting for Api response\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Got faked recording from Api\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Could not fetch from Api\" />}\n      {uiState === 'errorSources' && <ErrorMessage reason=\"Souces are not ready\" />}\n    </div>\n  );\n};\n","import { useEffect, useState } from 'react';\nimport { ErrorMessage, NeutralMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const StaticVideoLoader = (): React.ReactElement => {\n  const isAlreadyLoaded = useStore((state) => !!state.staticFiles);\n  const setStaticFiles = useStore((state) => state.setStaticFiles);\n\n  const [uiState, setUiState] = useState<'notLoaded' | 'loading' | 'loaded' | 'error'>(\n    isAlreadyLoaded ? 'loaded' : 'notLoaded',\n  );\n  useEffect(() => {\n    if (isAlreadyLoaded) return;\n\n    const loadVideos = async () => {\n      setUiState('loading');\n\n      try {\n        const start = await loadVideo('videos/1.mp4');\n        const middle = await loadAudio('videos/2.wav');\n        const end = await loadVideo('videos/3.mp4');\n        setUiState('loaded');\n        setStaticFiles({ start, middle, end });\n      } catch (error) {\n        setUiState('error');\n        console.warn(`Could not load element ${error?.path[0]?.src}`);\n        console.error(error);\n      }\n    };\n\n    loadVideos();\n  }, [isAlreadyLoaded, setStaticFiles]);\n\n  return (\n    <div className=\"StaticFileLoader\">\n      {uiState === 'notLoaded' && <NeutralMessage text=\"Files not loaded\" />}\n      {uiState === 'loading' && <NeutralMessage text=\"Files loading\" />}\n      {uiState === 'loaded' && <SuccessMessage text=\"Files loaded!\" />}\n      {uiState === 'error' && <ErrorMessage reason=\"Files could not load\" />}\n    </div>\n  );\n};\n\nconst loadVideo = async (src: string) => {\n  return new Promise<HTMLVideoElement>(async (resolve, reject) => {\n    const blob = await (await fetch(src)).blob();\n    const video = document.createElement('video') as HTMLVideoElement;\n    video.src = URL.createObjectURL(blob);\n    video.onerror = (event) => reject(event);\n    video.onloadeddata = () => {\n      resolve(video);\n    };\n    video.load();\n  });\n};\n\nconst loadAudio = async (src: string) => {\n  return new Promise<HTMLAudioElement>((resolve, reject) => {\n    const audio = document.createElement('audio') as HTMLAudioElement;\n    audio.src = src;\n    audio.load();\n    audio.onerror = (error) => reject(error);\n    audio.oncanplaythrough = () => {\n      resolve(audio);\n      audio.oncanplaythrough = null;\n    };\n  });\n};\n","import { useEffect } from 'react';\nimport { ErrorMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const VideosReadyDev = (): React.ReactElement => {\n  const maybeStaticVideos = useStore((state) => state.staticFiles);\n  const maybeFakeRecordingPromise = useStore((state) => state.fakedRecordingPromise);\n  const setPlaybackReadiness = useStore((state) => state.setPlaybackReadiness);\n\n  useEffect(() => {\n    if (!maybeStaticVideos || !maybeFakeRecordingPromise) {\n      setPlaybackReadiness(false);\n    } else {\n      setPlaybackReadiness(true);\n    }\n  }, [maybeFakeRecordingPromise, maybeStaticVideos, setPlaybackReadiness]);\n\n  if (!maybeStaticVideos) {\n    return <ErrorMessage reason=\"Static videos not loaded\"></ErrorMessage>;\n  }\n  if (!maybeFakeRecordingPromise) {\n    return <ErrorMessage reason=\"Fake recording not received\"></ErrorMessage>;\n  }\n\n  return <SuccessMessage text=\"Videos Ready\"></SuccessMessage>;\n};\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { SuccessMessage, ErrorMessage, NeutralMessage } from './ui/Messages';\n\nlet controller = new AbortController();\nlet signal = controller.signal;\n\nfunction fetchStatusHandler(response: Response): Response {\n  if (response.status === 200) {\n    return response;\n  } else {\n    throw new Error(response.statusText);\n  }\n}\n\nexport const ApiUpTest = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const testApi = useCallback(async () => {\n    try {\n      const response = await fetch(apiUrl + '/three_videos_is_up', {\n        method: 'POST',\n        mode: 'cors',\n        body: new FormData(),\n        signal,\n      }).then(fetchStatusHandler);\n      const file = await response.blob();\n      if (file.size <= 0) {\n        throw new Error('API Failed. Did not get blob successfully');\n      }\n      setUiState('success');\n    } catch (error) {\n      setUiState('errorApi');\n      console.error(error);\n    }\n  }, [apiUrl]);\n\n  useEffect(() => {\n    testApi();\n    const interval = setInterval(async () => {\n      controller.abort();\n      controller = new AbortController();\n      signal = controller.signal;\n      await testApi();\n    }, 10000);\n\n    return () => clearInterval(interval);\n  }, [testApi]);\n\n  const [uiState, setUiState] = useState<'idle' | 'success' | 'errorApi'>('idle');\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'idle' && <NeutralMessage text=\"Api test idle\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Api is Up\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Api is down\" />}\n    </div>\n  );\n};\n","import { ReactElement } from 'react';\n\nimport './LabelledInput.css';\n\ntype Props = {\n  label: string;\n} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n\nexport const LabelledInput = (props: Props): ReactElement => {\n  return (\n    <div className=\"LabelledInput\">\n      <label className=\"Label\">\n        <span>{props.label} </span>\n        <input className=\"Input\" {...props}>\n          {props.children}\n        </input>\n      </label>\n    </div>\n  );\n};\n","import { ReactElement } from 'react';\n\nimport './LabelledSelect.css';\n\ntype Props = {\n  label: string;\n  options: [value: React.OptionHTMLAttributes<HTMLOptionElement>['value'], text: string][];\n} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLSelectElement>, HTMLSelectElement>;\n\nexport const LabelledSelect = (props: Props): ReactElement => {\n  return (\n    <div className=\"LabelledSelect\">\n      <label className=\"Label\">\n        <span>{props.label} </span>\n        <select className=\"Select\" {...props}>\n          {props.options.map(([value, text], index) => (\n            <option key={index} value={value}>\n              {text}\n            </option>\n          ))}\n        </select>\n      </label>\n    </div>\n  );\n};\n","import { ChangeEvent, ReactElement } from 'react';\nimport { LabelledInput } from './ui/LabelledInput';\nimport { store, useStore } from './Store';\nimport { LabelledSelect } from './ui/LabelledSelect';\n\nexport const Config = (): ReactElement => {\n  const webcamScale = useStore((state) => state.config.webcamScale);\n  const recordingDuration = useStore((state) => state.config.recordingDuration);\n  const apiUrl = useStore((state) => state.config.apiUrl);\n  const onDurationChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const recordingDuration = parseInt(event.target.value, 10);\n\n    store.setState({ config: { ...config, recordingDuration } });\n  };\n\n  const onApiUrlChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const apiUrl = event.target.value;\n\n    store.setState({ config: { ...config, apiUrl } });\n  };\n\n  const onScaleChange = (event: ChangeEvent<HTMLSelectElement>) => {\n    const config = store.getState().config;\n    const webcamScale = parseInt(event.target.value, 10);\n\n    store.setState({ config: { ...config, webcamScale } });\n  };\n  return (\n    <div className=\"Config\">\n      <LabelledInput\n        label=\"Recording Duration:\"\n        name=\"recordingDuration\"\n        type=\"number\"\n        min={0}\n        max={16}\n        value={recordingDuration}\n        onChange={onDurationChange}\n      ></LabelledInput>\n\n      <LabelledInput\n        label=\"API Url:\"\n        name=\"apiUrl\"\n        type=\"string\"\n        value={apiUrl}\n        onChange={onApiUrlChange}\n      ></LabelledInput>\n\n      <LabelledSelect\n        label=\"Webcam Scale\"\n        options={[\n          [1, '100%'],\n          [2, '50%'],\n          [3, '33%'],\n          [4, '25%'],\n        ]}\n        value={webcamScale}\n        onChange={onScaleChange}\n      ></LabelledSelect>\n    </div>\n  );\n};\n","import React, { ReactElement, useRef, useState } from 'react';\nimport { Api } from './Api';\nimport { StaticVideoLoader } from './StaticFileLoader';\n\nimport './DevUi.css';\nimport { VideosReadyDev } from './VideosReadyDev';\nimport { ApiUpTest } from './ApiUpTest';\nimport { Config } from './Config';\nimport { store, useStore } from './Store';\nimport { Button } from './ui/Button';\n\nexport const DevUi = (): ReactElement => {\n  const apiUrl = useStore((state) => state.config.apiUrl);\n  const [isDevUiShowing, setDevUiShowing] = useState(true);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const noTranslation = `translate(0, 0)`;\n  const [menuTranslation, setMenuTranslation] = useState(noTranslation);\n\n  const toggleUi = () => {\n    setDevUiShowing(!isDevUiShowing);\n    const maybeBottom = buttonRef.current?.getBoundingClientRect().bottom;\n\n    if (isDevUiShowing && maybeBottom) {\n      const menuTranslation = `translate(0, ${window.innerHeight - maybeBottom}px)`;\n      setMenuTranslation(menuTranslation);\n    } else {\n      setMenuTranslation(noTranslation);\n    }\n  };\n\n  return (\n    <div style={{ transform: menuTranslation }} className={`DevUi`}>\n      <Button ref={buttonRef} onClick={toggleUi}>\n        {isDevUiShowing ? 'Hide' : 'Show'}\n      </Button>\n      <Config />\n      <StaticVideoLoader />\n      <ApiUpTest apiUrl={apiUrl} />\n      <Api apiUrl={apiUrl} />\n      <VideosReadyDev />\n      <Button onClick={store.getState().resetState}>Reset State</Button>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { useStore } from './Store';\nimport { ErrorMessage, PromptMessage } from './ui/Messages';\nimport { Button } from './ui/Button';\n\nexport const VideoPermissions = (): React.ReactElement => {\n  const isVideoStreamOn = useStore((state) => !!state.videoStream);\n  const setVideoStream = useStore((state) => state.setVideoStream);\n\n  const [uiState, setUiState] = useState<\n    'prompt' | 'accepted' | 'errorVideo' | 'errorDisconnected'\n  >(isVideoStreamOn ? 'accepted' : 'prompt');\n\n  if (uiState === 'accepted') {\n  }\n\n  if (isVideoStreamOn && uiState !== 'accepted') {\n    setUiState('accepted');\n  }\n\n  if (!isVideoStreamOn && uiState === 'accepted') {\n    setUiState('errorDisconnected');\n  }\n\n  const getStreams = async () => {\n    const videoStream = await getVideoStream();\n\n    if (!videoStream) {\n      setUiState('errorVideo');\n      return;\n    }\n\n    setVideoStream(videoStream);\n  };\n\n  return (\n    <div className=\"Permissions\">\n      <PromptMessage\n        text={\n          'This is an interactive documentary. The interaction is provided via your microphone and webcam. Please enable this now.'\n        }\n      ></PromptMessage>\n\n      <Button onClick={getStreams}>Enable Webcam</Button>\n\n      {uiState === 'accepted' && <PromptMessage text={'Devices connected!'}></PromptMessage>}\n      {uiState === 'errorVideo' && <ErrorMessage reason={'Could not get webcam.'} />}\n      {uiState === 'errorDisconnected' && <ErrorMessage reason={'Devices disconnected.'} />}\n    </div>\n  );\n};\n\nasync function getVideoStream() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { width: 1280, height: 720, facingMode: 'user' },\n      audio: false,\n    });\n    return stream;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n","import React, { useEffect, useMemo, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { NeutralMessage, PromptMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\ntype Props = {\n  stream: MediaStream;\n  duration: number;\n};\n\nexport const VideoRecorder = ({ stream, duration }: Props): React.ReactElement => {\n  const [timeRemaining, setTimeRemaining] = useState(duration);\n  const [isRecording, setIsRecording] = useState(false);\n\n  const setVideoRecording = useStore((state) => state.setVideoRecording);\n  const videoRecorder = useMemo(() => getVideoRecorder(stream), [stream]);\n\n  const [uiState, setUiState] = useState<'prompt' | 'recording' | 'recorded'>('prompt');\n  useEffect(() => {\n    if (isRecording) return;\n    if (uiState === 'recorded') return;\n\n    setUiState('prompt');\n    setTimeRemaining(duration);\n    setIsRecording(false);\n  }, [isRecording, uiState, stream, duration]);\n\n  useEffect(() => {\n    if (!isRecording) return;\n    const timeout = setTimeout(async () => {\n      if (timeRemaining > 0) {\n        setTimeRemaining(timeRemaining - 1);\n        return;\n      }\n\n      const { videoBlob: blob, videoUrl: url } = await videoRecorder.stop();\n      setUiState('recorded');\n      setIsRecording(false);\n      setVideoRecording({ blob, url });\n    }, 1000);\n\n    return () => clearTimeout(timeout);\n  }, [isRecording, setVideoRecording, timeRemaining, videoRecorder]);\n\n  const recordVideo = () => {\n    setTimeRemaining(duration);\n    setUiState('recording');\n    setIsRecording(true);\n    videoRecorder.start();\n  };\n\n  return (\n    <div className=\"VideoRecorder\">\n      {uiState === 'prompt' && (\n        <PromptMessage\n          text={`Our AI needs to be trained. Please record ${duration} seconds of your webcam`}\n        ></PromptMessage>\n      )}\n      {uiState === 'recording' && (\n        <NeutralMessage text={`Recoding for another: ${timeRemaining}s`}></NeutralMessage>\n      )}\n      {uiState === 'recorded' && <SuccessMessage text={`Trained!`}></SuccessMessage>}\n      {uiState !== 'recording' && <Button onClick={recordVideo}>Record Video</Button>}\n    </div>\n  );\n};\n\ntype VideoRecorderResult = {\n  start: () => void;\n  stop: () => Promise<{\n    videoBlob: Blob;\n    videoUrl: string;\n  }>;\n};\n\nconst getVideoRecorder = (stream: MediaStream): VideoRecorderResult => {\n  const options = { mimeType: 'video/webm; codecs=h264' };\n  const mediaRecorder = new MediaRecorder(stream, options);\n  const videoChunks: Blob[] = [];\n\n  mediaRecorder.addEventListener('dataavailable', (event) => {\n    videoChunks.push(event.data);\n  });\n\n  const start = () => {\n    videoChunks.length = 0;\n    mediaRecorder.start();\n  };\n\n  const stop = () =>\n    new Promise<{ videoBlob: Blob; videoUrl: string }>((resolve) => {\n      mediaRecorder.addEventListener('stop', () => {\n        const videoBlob = new Blob(videoChunks, {\n          type: 'video/webm',\n        });\n        const videoUrl = URL.createObjectURL(videoBlob);\n\n        resolve({ videoBlob, videoUrl });\n      });\n\n      mediaRecorder.stop();\n    });\n\n  return { start, stop };\n};\n","import React, { useEffect, useRef } from 'react';\nimport './VideoStreamPreview.css';\n\ntype Props = {\n  stream: MediaStream;\n};\n\nexport const VideoStreamPreview = ({ stream }: Props): React.ReactElement => {\n  const ref = useRef<HTMLVideoElement | null>(null);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    ref.current.srcObject = stream;\n  }, [stream]);\n\n  return (\n    <div className=\"VideoStreamPreview\">\n      <video autoPlay={true} ref={ref}></video>\n    </div>\n  );\n};\n","import React, { ReactElement } from 'react';\nimport { VideoPermissions } from './VideoPermissions';\nimport { useStore } from './Store';\nimport { VideoRecorder } from './VideoRecorder';\nimport { VideoStreamPreview } from './ui/VideoStreamPreview';\n\nimport './UserUi.css';\n\nexport const UserUi = (): ReactElement => {\n  const isVideoPermissionGranted = useStore((state) => !!state.videoStream);\n  const stream = useStore((state) => state.videoStream);\n  const isPlaybackReady = useStore((state) => state.isPlaybackReady);\n  const recordingDuration = useStore((state) => state.config.recordingDuration);\n\n  return (\n    <>\n      {!isPlaybackReady && (\n        <div className=\"UserUi\">\n          {!isVideoPermissionGranted && <VideoPermissions />}\n          {stream !== undefined && (\n            <>\n              <VideoRecorder stream={stream} duration={recordingDuration} />\n              <VideoStreamPreview stream={stream} />\n            </>\n          )}\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport './App.css';\nimport { AsyncVideos } from './AsyncVideos';\nimport { DevUi } from './DevUi';\nimport { useStore } from './Store';\nimport { UserUi } from './UserUi';\n\nfunction App(): React.ReactElement {\n  const startVideo = useStore((state) => state.staticFiles?.start);\n  const endVideo = useStore((state) => state.staticFiles?.end);\n  const fakedRecordingPromise = useStore((state) => state.fakedRecordingPromise);\n\n  return (\n    <div className=\"App\">\n      <div className=\"AppContents\">\n        <UserUi />\n        <DevUi />\n        {!!startVideo && !!fakedRecordingPromise && !!endVideo && (\n          <AsyncVideos start={startVideo} middle={fakedRecordingPromise} end={endVideo} />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}