{"version":3,"sources":["AsyncVideos.tsx","ui/Button.tsx","ui/Messages.tsx","Store.tsx","Api.tsx","videos/1.mp4","videos/2.wav","videos/3.mp4","StaticFileLoader.tsx","VideosReadyDev.tsx","ApiUpTest.tsx","ui/LabelledInput.tsx","ui/LabelledSelect.tsx","Config.tsx","DevUi.tsx","Permissions.tsx","VideoRecorder.tsx","ui/VideoStreamPreview.tsx","UserUi.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["AsyncVideos","start","middle","end","canvasRef","useRef","useState","videos","setVideos","width","height","size","setSize","currentVideoIndex","setCurrentVideoIndex","useEffect","a","videoPromises","map","blob","index","setSizeCallback","video","videoWidth","videoHeight","loadVideo","effect","useAnimationFrame","currentVideo","context","current","getContext","undefined","drawImage","pauseVideo","length","Error","onended","currentTime","paused","ended","readyState","console","log","play","pause","then","ref","videoBlob","onMetaData","Promise","resolve","reject","document","createElement","src","URL","createObjectURL","load","onloadeddata","onerror","error","addEventListener","frameRate","callback","requestRef","previousTimeRef","animate","useCallback","time","deltaTime","interval","setInterval","requestAnimationFrame","cancelAnimationFrame","clearInterval","Button","forwardRef","props","className","children","ErrorMessage","reason","PromptMessage","text","SuccessMessage","NeutralMessage","initialState","streams","recordings","fakedRecording","fakedRecordingPromise","staticFiles","isPlaybackReady","config","recordingDuration","apiUrl","webcamScale","store","create","set","get","setStreams","closeStreams","audio","getTracks","forEach","track","maybeStreams","stop","setVideoRecording","recording","setStaticFiles","setFakedRecording","setFakedRecordingPromise","videoPromise","setPlaybackReadiness","isReady","resetState","useStore","createStoreHook","Api","audioSource","state","destinationVideo","resultVideo","uiState","setUiState","sendToApi","formData","FormData","append","toFixed","fakedVideoPromise","fetch","method","body","mode","response","includes","onClick","StaticVideoLoader","isAlreadyLoaded","videoSrcStart","videoSrcMiddle","videoSrcEnd","loadVideos","VideosReadyDev","maybeStaticVideos","maybeFakeRecordingPromise","controller","AbortController","signal","fetchStatusHandler","status","statusText","ApiUpTest","testApi","abort","LabelledInput","label","LabelledSelect","options","value","Config","name","type","min","max","onChange","event","getState","parseInt","target","setState","DevUi","isDevUiShowing","setDevUiShowing","buttonRef","noTranslation","menuTranslation","setMenuTranslation","style","transform","maybeBottom","getBoundingClientRect","bottom","window","innerHeight","Permissions","isUserStreamOn","getStreams","getAudioStream","getVideoStream","navigator","mediaDevices","getUserMedia","stream","facingMode","VideoRecorder","duration","timeRemaining","setTimeRemaining","isRecording","setIsRecording","videoRecorder","useMemo","getVideoRecorder","timeout","setTimeout","url","videoUrl","clearTimeout","mediaRecorder","MediaRecorder","mimeType","videoChunks","push","data","Blob","VideoStreamPreview","srcObject","autoPlay","UserUi","isPermissionGranted","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7cfd97ac.chunk.js","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\ntype Props = {\n  start: Blob;\n  middle: Promise<Blob>;\n  end: Blob;\n};\n\nconst isVideoPlaying = (video: HTMLVideoElement) =>\n  !!(video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2);\n\nexport const AsyncVideos = ({ start, middle, end }: Props): React.ReactElement => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [videos, setVideos] = useState<Promise<HTMLVideoElement>[]>([]);\n  const [size, setSize] = useState<{ width: number; height: number }>({ width: 0, height: 0 });\n  const [currentVideoIndex, setCurrentVideoIndex] = useState<number>(0);\n\n  useEffect(() => {\n    const effect = async () => {\n      const videoPromises = [start, middle, end].map(async (blob, index) => {\n        const isFirst = index === 0;\n        const setSizeCallback = isFirst\n          ? (video: HTMLVideoElement) =>\n              setSize({ width: video.videoWidth, height: video.videoHeight })\n          : () => ({});\n        return loadVideo(await blob, setSizeCallback);\n      });\n\n      setVideos(videoPromises);\n    };\n\n    effect();\n  }, [end, middle, start]);\n\n  useAnimationFrame(60, async () => {\n    const currentVideo = await videos[currentVideoIndex];\n    const context = canvasRef.current?.getContext('2d');\n    if (currentVideo === undefined) return;\n    if (context === undefined || context === null) return;\n\n    context.drawImage(currentVideo, 0, 0, size.width, size.height);\n  });\n\n  useEffect(() => {\n    const effect = async () => {\n      if (videos.length === 0) return;\n      const currentVideo = await videos[currentVideoIndex];\n      if (currentVideo === undefined)\n        throw new Error(\n          `currentVideoIndex out of range. Got ${currentVideoIndex}, expected between 0 and ${videos.length}`,\n        );\n      currentVideo.onended = () => setCurrentVideoIndex((currentVideoIndex + 1) % videos.length);\n      if (!isVideoPlaying(currentVideo)) {\n        console.log(`playing video ${currentVideoIndex}`);\n        currentVideo.play();\n      }\n\n      return () => {\n        currentVideo.pause();\n      };\n    };\n\n    const pauseVideo = effect();\n\n    return () => {\n      pauseVideo.then((pause) => pause?.());\n    };\n  }, [currentVideoIndex, videos]);\n\n  return <canvas ref={canvasRef} width={size.width} height={size.height}></canvas>;\n};\n\nasync function loadVideo(videoBlob: Blob, onMetaData: (video: HTMLVideoElement) => void) {\n  return new Promise<HTMLVideoElement>((resolve, reject) => {\n    const video = document.createElement('video');\n    video.src = URL.createObjectURL(videoBlob);\n    video.load();\n    video.onloadeddata = () => resolve(video);\n    video.onerror = (error) => reject(error);\n    video.addEventListener('loadedmetadata', () => onMetaData(video));\n  });\n}\n\nexport const useAnimationFrame = (\n  frameRate: number,\n  callback: (deltaTime: number) => void,\n): void => {\n  const requestRef = useRef<number>();\n  const previousTimeRef = useRef<number>();\n\n  const animate = useCallback(\n    (time: number) => {\n      if (previousTimeRef.current !== undefined) {\n        const deltaTime = time - previousTimeRef.current;\n        callback(deltaTime);\n      }\n      previousTimeRef.current = time;\n    },\n    [callback],\n  );\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      requestRef.current = requestAnimationFrame(animate);\n    }, 1000 / frameRate);\n    return () => {\n      requestRef.current && cancelAnimationFrame(requestRef.current);\n      interval && clearInterval(interval);\n    };\n  }, [animate, frameRate]);\n};\n","import { forwardRef } from 'react';\n\nimport './Button.css';\n\nexport const Button = forwardRef<HTMLButtonElement, React.ButtonHTMLAttributes<HTMLButtonElement>>(\n  (props, ref) => {\n    return (\n      <button ref={ref} className=\"Button\" {...props}>\n        {props.children}\n      </button>\n    );\n  },\n);\n","import './Messages.css';\n\nexport const ErrorMessage = ({ reason }: { reason: string }): React.ReactElement => {\n  return (\n    <div className=\"Message ErrorMessage\">\n      <span>Error: {reason}</span>\n    </div>\n  );\n};\n\nexport const PromptMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message PromptMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n\nexport const SuccessMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message SuccessMessage\">\n      <span>Success: {text}</span>\n    </div>\n  );\n};\n\nexport const NeutralMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message NeutralMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n","import create from 'zustand/vanilla';\nimport createStoreHook from 'zustand';\n\ntype Recording = {\n  blob: Blob;\n  url: string;\n};\n\ninterface Streams {\n  video: MediaStream;\n  audio: MediaStream;\n}\n\ntype State = {\n  streams: Streams | undefined;\n  staticFiles: { start: Blob; middle: Blob; end: Blob } | undefined;\n  recordings: { video?: Recording; audio?: Recording };\n  fakedRecording: Blob | undefined;\n  fakedRecordingPromise: Promise<Blob> | undefined;\n  isPlaybackReady: boolean;\n  config: {\n    recordingDuration: number;\n    apiUrl: string;\n    webcamScale: number;\n  };\n  setStreams: (streams: Streams) => void;\n  closeStreams: () => void;\n  setVideoRecording: (recording: Recording) => void;\n  setStaticFiles: (start: Blob, middle: Blob, end: Blob) => void;\n  setFakedRecording: (video: Blob) => void;\n  setFakedRecordingPromise: (videoPromise: Promise<Blob>) => void;\n  setPlaybackReadiness: (isReady: boolean) => void;\n  resetState: () => void;\n};\n\ntype CallbackFunctionVariadic = (...args: never[]) => void;\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends CallbackFunctionVariadic ? never : K;\n}[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\nconst initialState: NonFunctionProperties<State> = {\n  streams: undefined,\n  recordings: {},\n  fakedRecording: undefined,\n  fakedRecordingPromise: undefined,\n  staticFiles: undefined,\n  isPlaybackReady: false,\n  config: { recordingDuration: 10, apiUrl: 'http://localhost:9000', webcamScale: 2 },\n};\n\nexport const store = create<State>((set, get) => ({\n  ...initialState,\n  setStreams: (streams: Streams) => {\n    get().closeStreams();\n    const { audio, video } = streams;\n\n    audio.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    video.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    set({ streams });\n  },\n  closeStreams: () => {\n    const maybeStreams = get().streams;\n    if (maybeStreams) {\n      const { audio, video } = maybeStreams;\n      audio.getTracks().forEach((track) => {\n        track.stop();\n      });\n      video.getTracks().forEach((track) => {\n        track.stop();\n      });\n    }\n    set({ streams: undefined });\n  },\n\n  setVideoRecording: (recording) => {\n    set({ recordings: { video: recording } });\n  },\n  setStaticFiles: (start, middle, end) => {\n    set({ staticFiles: { start, middle, end } });\n  },\n  setFakedRecording: (video) => {\n    set({ fakedRecording: video });\n  },\n\n  setFakedRecordingPromise: (videoPromise) => {\n    set({ fakedRecordingPromise: videoPromise });\n  },\n\n  setPlaybackReadiness: (isReady: boolean) => set({ isPlaybackReady: isReady }),\n  resetState: () => {\n    const config = { ...get().config };\n    set({ ...initialState, config: { ...config } });\n  },\n}));\n\nexport const useStore = createStoreHook(store);\n","import React, { useEffect, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { SuccessMessage, ErrorMessage, NeutralMessage, PromptMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const Api = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const audioSource = useStore((state) => state.staticFiles?.middle);\n  const destinationVideo = useStore((state) => state.recordings?.video);\n  const resultVideo = useStore((state) => state.fakedRecording);\n  const webcamScale = useStore((state) => state.config.webcamScale);\n\n  const setFakedRecording = useStore((state) => state.setFakedRecording);\n  const setFakedRecordingPromise = useStore((state) => state.setFakedRecordingPromise);\n\n  const [uiState, setUiState] = useState<\n    | 'awaitingAudioSource'\n    | 'awaitingDestinationVideo'\n    | 'prompt'\n    | 'awaitingResult'\n    | 'success'\n    | 'errorApi'\n    | 'errorSources'\n  >(\n    audioSource === undefined\n      ? 'awaitingAudioSource'\n      : destinationVideo === undefined\n      ? 'awaitingDestinationVideo'\n      : !!resultVideo\n      ? 'success'\n      : 'prompt',\n  );\n\n  useEffect(() => {\n    const uiState =\n      audioSource === undefined\n        ? 'awaitingAudioSource'\n        : destinationVideo === undefined\n        ? 'awaitingDestinationVideo'\n        : !!resultVideo\n        ? 'success'\n        : 'prompt';\n\n    setUiState(uiState);\n  }, [audioSource, destinationVideo, resultVideo]);\n\n  const sendToApi = async () => {\n    if (!audioSource || !destinationVideo) {\n      console.error(\n        `Not all sources are ready. source: ${audioSource}, destination: ${destinationVideo})`,\n      );\n      setUiState('errorSources');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('image', destinationVideo.blob);\n    formData.append('sound', audioSource);\n    formData.append('webcamScale', webcamScale.toFixed(0));\n\n    const fakedVideoPromise = new Promise<Blob>(async (resolve, reject) => {\n      try {\n        setUiState('awaitingResult');\n        const response = await fetch(apiUrl + '/three_videos_demo', {\n          method: 'POST',\n          body: formData,\n          mode: 'cors',\n        });\n\n        const video = await response.blob();\n        setUiState('success');\n        setFakedRecording(video);\n        resolve(video);\n      } catch (error) {\n        setUiState('errorApi');\n        console.error(error);\n        reject(error);\n      }\n    });\n\n    setFakedRecordingPromise(fakedVideoPromise);\n  };\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'awaitingAudioSource' && <NeutralMessage text=\"Awaiting audio source\" />}\n      {uiState === 'awaitingDestinationVideo' && (\n        <NeutralMessage text=\"Awaiting destination video\" />\n      )}\n      {uiState === 'prompt' && <PromptMessage text=\"Source and Destination ready to be faked\" />}\n      {!uiState.includes('awaiting') && <Button onClick={sendToApi}>Send to API</Button>}\n      {uiState === 'awaitingResult' && <NeutralMessage text=\"Waiting for Api response\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Got faked recording from Api\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Could not fetch from Api\" />}\n      {uiState === 'errorSources' && <ErrorMessage reason=\"Souces are not ready\" />}\n    </div>\n  );\n};\n","export default __webpack_public_path__ + \"static/media/1.6f4d89fa.mp4\";","export default __webpack_public_path__ + \"static/media/2.7754dc8c.wav\";","export default __webpack_public_path__ + \"static/media/3.7bc44234.mp4\";","import { useEffect, useState } from 'react';\nimport { ErrorMessage, NeutralMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nimport videoSrcStart from './videos/1.mp4';\nimport videoSrcMiddle from './videos/2.wav';\nimport videoSrcEnd from './videos/3.mp4';\n\nexport const StaticVideoLoader = (): React.ReactElement => {\n  const isAlreadyLoaded = useStore((state) => !!state.staticFiles);\n  const setStaticFiles = useStore((state) => state.setStaticFiles);\n\n  const [uiState, setUiState] = useState<'notLoaded' | 'loading' | 'loaded' | 'error'>(\n    isAlreadyLoaded ? 'loaded' : 'notLoaded',\n  );\n  useEffect(() => {\n    if (isAlreadyLoaded) return;\n\n    const loadVideos = async () => {\n      setUiState('loading');\n\n      try {\n        const start = await (await fetch(videoSrcStart)).blob();\n        const middle = await (await fetch(videoSrcMiddle)).blob();\n        const end = await (await fetch(videoSrcEnd)).blob();\n        setUiState('loaded');\n        setStaticFiles(start, middle, end);\n      } catch (error) {\n        setUiState('error');\n        console.error(error);\n      }\n    };\n\n    loadVideos();\n  }, [isAlreadyLoaded, setStaticFiles]);\n\n  return (\n    <div className=\"StaticFileLoader\">\n      {uiState === 'notLoaded' && <NeutralMessage text=\"Files not loaded\" />}\n      {uiState === 'loading' && <NeutralMessage text=\"Files loading\" />}\n      {uiState === 'loaded' && <SuccessMessage text=\"Files loaded!\" />}\n      {uiState === 'error' && <ErrorMessage reason=\"Files could not load\" />}\n    </div>\n  );\n};\n","import { useEffect } from 'react';\nimport { ErrorMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const VideosReadyDev = (): React.ReactElement => {\n  const maybeStaticVideos = useStore((state) => state.staticFiles);\n  const maybeFakeRecordingPromise = useStore((state) => state.fakedRecordingPromise);\n  const setPlaybackReadiness = useStore((state) => state.setPlaybackReadiness);\n\n  useEffect(() => {\n    if (!maybeStaticVideos || !maybeFakeRecordingPromise) {\n      setPlaybackReadiness(false);\n    } else {\n      setPlaybackReadiness(true);\n    }\n  }, [maybeFakeRecordingPromise, maybeStaticVideos, setPlaybackReadiness]);\n\n  if (!maybeStaticVideos) {\n    return <ErrorMessage reason=\"Static videos not loaded\"></ErrorMessage>;\n  }\n  if (!maybeFakeRecordingPromise) {\n    return <ErrorMessage reason=\"Fake recording not received\"></ErrorMessage>;\n  }\n\n  return <SuccessMessage text=\"Videos Ready\"></SuccessMessage>;\n};\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { SuccessMessage, ErrorMessage, NeutralMessage } from './ui/Messages';\n\nlet controller = new AbortController();\nlet signal = controller.signal;\n\nfunction fetchStatusHandler(response: Response): Response {\n  if (response.status === 200) {\n    return response;\n  } else {\n    throw new Error(response.statusText);\n  }\n}\n\nexport const ApiUpTest = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const testApi = useCallback(async () => {\n    try {\n      const response = await fetch(apiUrl + '/three_videos_is_up', {\n        method: 'POST',\n        mode: 'cors',\n        body: new FormData(),\n        signal,\n      }).then(fetchStatusHandler);\n      const file = await response.blob();\n      if (file.size <= 0) {\n        throw new Error('API Failed. Did not get blob successfully');\n      }\n      setUiState('success');\n    } catch (error) {\n      setUiState('errorApi');\n      console.error(error);\n    }\n  }, [apiUrl]);\n\n  useEffect(() => {\n    testApi();\n    const interval = setInterval(async () => {\n      controller.abort();\n      controller = new AbortController();\n      signal = controller.signal;\n      await testApi();\n    }, 10000);\n\n    return () => clearInterval(interval);\n  }, [testApi]);\n\n  const [uiState, setUiState] = useState<'idle' | 'success' | 'errorApi'>('idle');\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'idle' && <NeutralMessage text=\"Api test idle\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Api is Up\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Api is down\" />}\n    </div>\n  );\n};\n","import { ReactElement } from 'react';\n\nimport './LabelledInput.css';\n\ntype Props = {\n  label: string;\n} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n\nexport const LabelledInput = (props: Props): ReactElement => {\n  return (\n    <div className=\"LabelledInput\">\n      <label className=\"Label\">\n        <span>{props.label} </span>\n        <input className=\"Input\" {...props}>\n          {props.children}\n        </input>\n      </label>\n    </div>\n  );\n};\n","import { ReactElement } from 'react';\n\nimport './LabelledSelect.css';\n\ntype Props = {\n  label: string;\n  options: [value: React.OptionHTMLAttributes<HTMLOptionElement>['value'], text: string][];\n} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLSelectElement>, HTMLSelectElement>;\n\nexport const LabelledSelect = (props: Props): ReactElement => {\n  return (\n    <div className=\"LabelledSelect\">\n      <label className=\"Label\">\n        <span>{props.label} </span>\n        <select className=\"Select\" {...props}>\n          {props.options.map(([value, text], index) => (\n            <option key={index} value={value}>\n              {text}\n            </option>\n          ))}\n        </select>\n      </label>\n    </div>\n  );\n};\n","import { ChangeEvent, ReactElement } from 'react';\nimport { LabelledInput } from './ui/LabelledInput';\nimport { store, useStore } from './Store';\nimport { LabelledSelect } from './ui/LabelledSelect';\n\nexport const Config = (): ReactElement => {\n  const webcamScale = useStore((state) => state.config.webcamScale);\n  const recordingDuration = useStore((state) => state.config.recordingDuration);\n  const apiUrl = useStore((state) => state.config.apiUrl);\n  const onDurationChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const recordingDuration = parseInt(event.target.value, 10);\n\n    store.setState({ config: { ...config, recordingDuration } });\n  };\n\n  const onApiUrlChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const apiUrl = event.target.value;\n\n    store.setState({ config: { ...config, apiUrl } });\n  };\n\n  const onScaleChange = (event: ChangeEvent<HTMLSelectElement>) => {\n    const config = store.getState().config;\n    const webcamScale = parseInt(event.target.value, 10);\n\n    store.setState({ config: { ...config, webcamScale } });\n  };\n  return (\n    <div className=\"Config\">\n      <LabelledInput\n        label=\"Recording Duration:\"\n        name=\"recordingDuration\"\n        type=\"number\"\n        min={0}\n        max={16}\n        value={recordingDuration}\n        onChange={onDurationChange}\n      ></LabelledInput>\n\n      <LabelledInput\n        label=\"API Url:\"\n        name=\"apiUrl\"\n        type=\"string\"\n        value={apiUrl}\n        onChange={onApiUrlChange}\n      ></LabelledInput>\n\n      <LabelledSelect\n        label=\"Webcam Scale\"\n        options={[\n          [1, '100%'],\n          [2, '50%'],\n          [3, '33%'],\n          [4, '25%'],\n        ]}\n        value={webcamScale}\n        onChange={onScaleChange}\n      ></LabelledSelect>\n    </div>\n  );\n};\n","import React, { ReactElement, useRef, useState } from 'react';\nimport { Api } from './Api';\nimport { StaticVideoLoader } from './StaticFileLoader';\n\nimport './DevUi.css';\nimport { VideosReadyDev } from './VideosReadyDev';\nimport { ApiUpTest } from './ApiUpTest';\nimport { Config } from './Config';\nimport { store, useStore } from './Store';\nimport { Button } from './ui/Button';\n\nexport const DevUi = (): ReactElement => {\n  const apiUrl = useStore((state) => state.config.apiUrl);\n  const [isDevUiShowing, setDevUiShowing] = useState(true);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const noTranslation = `translate(0, 0)`;\n  const [menuTranslation, setMenuTranslation] = useState(noTranslation);\n\n  const toggleUi = () => {\n    setDevUiShowing(!isDevUiShowing);\n    const maybeBottom = buttonRef.current?.getBoundingClientRect().bottom;\n\n    if (isDevUiShowing && maybeBottom) {\n      const menuTranslation = `translate(0, ${window.innerHeight - maybeBottom}px)`;\n      setMenuTranslation(menuTranslation);\n    } else {\n      setMenuTranslation(noTranslation);\n    }\n  };\n\n  return (\n    <div style={{ transform: menuTranslation }} className={`DevUi`}>\n      <Button ref={buttonRef} onClick={toggleUi}>\n        {isDevUiShowing ? 'Hide' : 'Show'}\n      </Button>\n      <Config />\n      <StaticVideoLoader />\n      <ApiUpTest apiUrl={apiUrl} />\n      <Api apiUrl={apiUrl} />\n      <VideosReadyDev />\n      <Button onClick={store.getState().resetState}>Reset State</Button>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { useStore } from './Store';\nimport { ErrorMessage, PromptMessage } from './ui/Messages';\nimport { Button } from './ui/Button';\n\nexport const Permissions = (): React.ReactElement => {\n  const isUserStreamOn = useStore((state) => !!state.streams);\n  const setStreams = useStore((state) => state.setStreams);\n\n  const [uiState, setUiState] = useState<\n    'prompt' | 'accepted' | 'errorVideo' | 'errorAudio' | 'errorDisconnected'\n  >(isUserStreamOn ? 'accepted' : 'prompt');\n\n  if (uiState === 'accepted') {\n  }\n\n  if (isUserStreamOn && uiState !== 'accepted') {\n    setUiState('accepted');\n  }\n\n  if (!isUserStreamOn && uiState === 'accepted') {\n    setUiState('errorDisconnected');\n  }\n\n  const getStreams = async () => {\n    const audio = await getAudioStream();\n    const video = await getVideoStream();\n\n    if (!audio) {\n      setUiState('errorAudio');\n      return;\n    }\n\n    if (!video) {\n      setUiState('errorVideo');\n      return;\n    }\n\n    setStreams({ audio, video });\n  };\n\n  return (\n    <div className=\"Permissions\">\n      <PromptMessage\n        text={\n          'This is an interactive documentary. The interaction is provided via your microphone and webcam. Please enable this now.'\n        }\n      ></PromptMessage>\n\n      <Button onClick={getStreams}>Enable Webcam & Audio</Button>\n\n      {uiState === 'accepted' && <PromptMessage text={'Devices connected!'}></PromptMessage>}\n      {uiState === 'errorAudio' && <ErrorMessage reason={'Could not get microphone.'} />}\n      {uiState === 'errorVideo' && <ErrorMessage reason={'Could not get webcam.'} />}\n      {uiState === 'errorDisconnected' && <ErrorMessage reason={'Devices disconnected.'} />}\n    </div>\n  );\n};\n\nasync function getAudioStream() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    return stream;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nasync function getVideoStream() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { width: 1280, height: 720, facingMode: 'user' },\n      audio: false,\n    });\n    return stream;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n","import React, { useEffect, useMemo, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { NeutralMessage, PromptMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\ntype Props = {\n  stream: MediaStream;\n  duration: number;\n};\n\nexport const VideoRecorder = ({ stream, duration }: Props): React.ReactElement => {\n  const [timeRemaining, setTimeRemaining] = useState(duration);\n  const [isRecording, setIsRecording] = useState(false);\n\n  const setVideoRecording = useStore((state) => state.setVideoRecording);\n  const videoRecorder = useMemo(() => getVideoRecorder(stream), [stream]);\n\n  const [uiState, setUiState] = useState<'prompt' | 'recording' | 'recorded'>('prompt');\n  useEffect(() => {\n    if (isRecording) return;\n    if (uiState === 'recorded') return;\n\n    setUiState('prompt');\n    setTimeRemaining(duration);\n    setIsRecording(false);\n  }, [isRecording, uiState, stream, duration]);\n\n  useEffect(() => {\n    if (!isRecording) return;\n    const timeout = setTimeout(async () => {\n      if (timeRemaining > 0) {\n        setTimeRemaining(timeRemaining - 1);\n        return;\n      }\n\n      const { videoBlob: blob, videoUrl: url } = await videoRecorder.stop();\n      setUiState('recorded');\n      setIsRecording(false);\n      setVideoRecording({ blob, url });\n    }, 1000);\n\n    return () => clearTimeout(timeout);\n  }, [isRecording, setVideoRecording, timeRemaining, videoRecorder]);\n\n  const recordVideo = () => {\n    setTimeRemaining(duration);\n    setUiState('recording');\n    setIsRecording(true);\n    videoRecorder.start();\n  };\n\n  return (\n    <div className=\"VideoRecorder\">\n      {uiState === 'prompt' && (\n        <PromptMessage\n          text={`Our AI needs to be trained. Please record ${duration} seconds of your webcam`}\n        ></PromptMessage>\n      )}\n      {uiState === 'recording' && (\n        <NeutralMessage text={`Recoding for another: ${timeRemaining}s`}></NeutralMessage>\n      )}\n      {uiState === 'recorded' && <SuccessMessage text={`Trained!`}></SuccessMessage>}\n      {uiState !== 'recording' && <Button onClick={recordVideo}>Record Video</Button>}\n    </div>\n  );\n};\n\ntype VideoRecorderResult = {\n  start: () => void;\n  stop: () => Promise<{\n    videoBlob: Blob;\n    videoUrl: string;\n  }>;\n};\n\nconst getVideoRecorder = (stream: MediaStream): VideoRecorderResult => {\n  const options = { mimeType: 'video/webm; codecs=h264' };\n  const mediaRecorder = new MediaRecorder(stream, options);\n  const videoChunks: Blob[] = [];\n\n  mediaRecorder.addEventListener('dataavailable', (event) => {\n    videoChunks.push(event.data);\n  });\n\n  const start = () => {\n    videoChunks.length = 0;\n    mediaRecorder.start();\n  };\n\n  const stop = () =>\n    new Promise<{ videoBlob: Blob; videoUrl: string }>((resolve) => {\n      mediaRecorder.addEventListener('stop', () => {\n        const videoBlob = new Blob(videoChunks, {\n          type: 'video/webm',\n        });\n        const videoUrl = URL.createObjectURL(videoBlob);\n\n        resolve({ videoBlob, videoUrl });\n      });\n\n      mediaRecorder.stop();\n    });\n\n  return { start, stop };\n};\n","import React, { useEffect, useRef } from 'react';\nimport './VideoStreamPreview.css';\n\ntype Props = {\n  stream: MediaStream;\n};\n\nexport const VideoStreamPreview = ({ stream }: Props): React.ReactElement => {\n  const ref = useRef<HTMLVideoElement | null>(null);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    ref.current.srcObject = stream;\n  }, [stream]);\n\n  return (\n    <div className=\"VideoStreamPreview\">\n      <video autoPlay={true} ref={ref}></video>\n    </div>\n  );\n};\n","import React, { ReactElement } from 'react';\nimport { Permissions } from './Permissions';\nimport { useStore } from './Store';\nimport { VideoRecorder } from './VideoRecorder';\nimport { VideoStreamPreview } from './ui/VideoStreamPreview';\n\nimport './UserUi.css';\n\nexport const UserUi = (): ReactElement => {\n  const isPermissionGranted = useStore((state) => !!state.streams);\n  const stream = useStore((state) => state.streams?.video);\n  const isPlaybackReady = useStore((state) => state.isPlaybackReady);\n  const recordingDuration = useStore((state) => state.config.recordingDuration);\n\n  return (\n    <>\n      {!isPlaybackReady && (\n        <div className=\"UserUi\">\n          {!isPermissionGranted && <Permissions />}\n          {stream !== undefined && (\n            <>\n              <VideoRecorder stream={stream} duration={recordingDuration} />\n              <VideoStreamPreview stream={stream} />\n            </>\n          )}\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport './App.css';\nimport { AsyncVideos } from './AsyncVideos';\nimport { DevUi } from './DevUi';\nimport { useStore } from './Store';\nimport { UserUi } from './UserUi';\n\nfunction App(): React.ReactElement {\n  const staticFiles = useStore((state) => state.staticFiles);\n  const fakedRecordingPromise = useStore((state) => state.fakedRecordingPromise);\n\n  return (\n    <div className=\"App\">\n      <div className=\"AppContents\">\n        <UserUi />\n        <DevUi />\n        {!!staticFiles && !!fakedRecordingPromise && (\n          <AsyncVideos\n            start={staticFiles.start}\n            middle={fakedRecordingPromise}\n            end={staticFiles.end}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}