{"version":3,"sources":["ui/Button.tsx","ui/Messages.tsx","Store.tsx","Api.tsx","videos/1.mp4","videos/2.mp4","videos/3.mp4","StaticFileLoader.tsx","VideosReadyDev.tsx","ApiUpTest.tsx","ui/LabelledInput.tsx","Config.tsx","DevUi.tsx","SequentialVideos.tsx","Permissions.tsx","VideoRecorder.tsx","ui/VideoStreamPreview.tsx","UserUi.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Button","props","className","children","ErrorMessage","reason","PromptMessage","text","SuccessMessage","NeutralMessage","initialState","streams","undefined","recordings","fakedRecording","staticVideos","isPlaybackReady","config","recordingDuration","apiUrl","store","create","set","get","setStreams","closeStreams","audio","video","getTracks","forEach","track","addEventListener","maybeStreams","stop","setVideoRecording","recording","setStaticVideos","start","middle","end","setFakedRecording","setPlaybackReadiness","isReady","resetState","useStore","createStoreHook","Api","audioSource","state","destinationVideo","resultVideo","useState","uiState","setUiState","useEffect","sendToApi","a","console","error","formData","FormData","append","blob","fetch","method","body","mode","response","includes","onClick","StaticVideoLoader","isAlreadyLoaded","setStaticFiles","videoSrcStart","videoSrcMiddle","videoSrcEnd","loadVideos","VideosReadyDev","maybeStaticVideos","maybeFakeRecording","controller","AbortController","signal","fetchStatusHandler","status","Error","statusText","ApiUpTest","testApi","useCallback","then","size","interval","setInterval","abort","clearInterval","LabelledInput","label","Config","name","type","min","max","defaultValue","getState","onChange","event","parseInt","target","value","setState","DevUi","SequentialVideos","canvasRef","useRef","videos","setVideos","width","height","setSize","currentVideoIndex","setCurrentVideoIndex","Promise","all","map","index","loadVideo","videoWidth","videoHeight","effect","useAnimationFrame","currentVideo","context","current","getContext","drawImage","length","onended","currentTime","paused","ended","readyState","log","play","pause","ref","videoBlob","onMetaData","resolve","reject","document","createElement","src","URL","createObjectURL","load","onloadeddata","onerror","frameRate","callback","requestRef","previousTimeRef","animate","time","deltaTime","requestAnimationFrame","cancelAnimationFrame","Permissions","isUserStreamOn","getStreams","getAudioStream","getVideoStream","navigator","mediaDevices","getUserMedia","stream","facingMode","VideoRecorder","duration","timeRemaining","setTimeRemaining","isRecording","setIsRecording","videoRecorder","useMemo","getVideoRecorder","timeout","setTimeout","url","videoUrl","clearTimeout","mediaRecorder","MediaRecorder","mimeType","videoChunks","push","data","Blob","VideoStreamPreview","srcObject","autoPlay","UserUi","isPermissionGranted","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f7e6b434.chunk.js","sourcesContent":["import { ReactElement } from 'react';\n\nimport './Button.css';\n\nexport const Button = (props: React.ButtonHTMLAttributes<HTMLButtonElement>): ReactElement => {\n  return (\n    <button className=\"Button\" {...props}>\n      {props.children}\n    </button>\n  );\n};\n","import './Messages.css';\n\nexport const ErrorMessage = ({ reason }: { reason: string }): React.ReactElement => {\n  return (\n    <div className=\"Message ErrorMessage\">\n      <span>Error: {reason}</span>\n    </div>\n  );\n};\n\nexport const PromptMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message PromptMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n\nexport const SuccessMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message SuccessMessage\">\n      <span>Success: {text}</span>\n    </div>\n  );\n};\n\nexport const NeutralMessage = ({ text }: { text: string }): React.ReactElement => {\n  return (\n    <div className=\"Message NeutralMessage\">\n      <span>{text}</span>\n    </div>\n  );\n};\n","import create from 'zustand/vanilla';\nimport createStoreHook from 'zustand';\n\ntype Recording = {\n  blob: Blob;\n  url: string;\n};\n\ninterface Streams {\n  video: MediaStream;\n  audio: MediaStream;\n}\n\ntype State = {\n  streams: Streams | undefined;\n  staticVideos: { start: Blob; middle: Blob; end: Blob } | undefined;\n  recordings: { video?: Recording; audio?: Recording };\n  fakedRecording: Blob | undefined;\n  isPlaybackReady: boolean;\n  config: {\n    recordingDuration: number;\n    apiUrl: string;\n  };\n  setStreams: (streams: Streams) => void;\n  closeStreams: () => void;\n  setVideoRecording: (recording: Recording) => void;\n  setStaticVideos: (start: Blob, middle: Blob, end: Blob) => void;\n  setFakedRecording: (video: Blob) => void;\n  setPlaybackReadiness: (isReady: boolean) => void;\n  resetState: () => void;\n};\n\ntype CallbackFunctionVariadic = (...args: never[]) => void;\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends CallbackFunctionVariadic ? never : K;\n}[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\nconst initialState: NonFunctionProperties<State> = {\n  streams: undefined,\n  recordings: {},\n  fakedRecording: undefined,\n  staticVideos: undefined,\n  isPlaybackReady: false,\n  config: { recordingDuration: 3, apiUrl: 'http://localhost:9000' },\n};\n\nexport const store = create<State>((set, get) => ({\n  ...initialState,\n  setStreams: (streams: Streams) => {\n    get().closeStreams();\n    const { audio, video } = streams;\n\n    audio.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    video.getTracks().forEach((track) => {\n      track.addEventListener('ended', () => {\n        get().closeStreams();\n      });\n    });\n\n    set({ streams });\n  },\n  closeStreams: () => {\n    const maybeStreams = get().streams;\n    if (maybeStreams) {\n      const { audio, video } = maybeStreams;\n      audio.getTracks().forEach((track) => {\n        track.stop();\n      });\n      video.getTracks().forEach((track) => {\n        track.stop();\n      });\n    }\n    set({ streams: undefined });\n  },\n\n  setVideoRecording: (recording) => {\n    set({ recordings: { video: recording } });\n  },\n  setStaticVideos: (start, middle, end) => {\n    set({ staticVideos: { start, middle, end } });\n  },\n  setFakedRecording: (video) => {\n    set({ fakedRecording: video });\n  },\n\n  setPlaybackReadiness: (isReady: boolean) => set({ isPlaybackReady: isReady }),\n  resetState: () => {\n    const { config } = get();\n    set({ ...initialState, ...config });\n  },\n}));\n\nexport const useStore = createStoreHook(store);\n","import React, { useEffect, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { SuccessMessage, ErrorMessage, NeutralMessage, PromptMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const Api = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const audioSource = useStore((state) => state.staticVideos?.middle);\n  const destinationVideo = useStore((state) => state.recordings?.video);\n  const resultVideo = useStore((state) => state.fakedRecording);\n\n  const setFakedRecording = useStore((state) => state.setFakedRecording);\n\n  const [uiState, setUiState] = useState<\n    | 'awaitingAudioSource'\n    | 'awaitingDestinationVideo'\n    | 'prompt'\n    | 'awaitingResult'\n    | 'success'\n    | 'errorApi'\n    | 'errorSources'\n  >(\n    audioSource === undefined\n      ? 'awaitingAudioSource'\n      : destinationVideo === undefined\n      ? 'awaitingDestinationVideo'\n      : !!resultVideo\n      ? 'success'\n      : 'prompt',\n  );\n\n  useEffect(() => {\n    const uiState =\n      audioSource === undefined\n        ? 'awaitingAudioSource'\n        : destinationVideo === undefined\n        ? 'awaitingDestinationVideo'\n        : !!resultVideo\n        ? 'success'\n        : 'prompt';\n\n    setUiState(uiState);\n  }, [audioSource, destinationVideo, resultVideo]);\n\n  const sendToApi = async () => {\n    if (!audioSource || !destinationVideo) {\n      console.error(\n        `Not all sources are ready. source: ${audioSource}, destination: ${destinationVideo})`,\n      );\n      setUiState('errorSources');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('image', destinationVideo.blob);\n    formData.append('sound', audioSource);\n\n    try {\n      setUiState('awaitingResult');\n      const response = await fetch(apiUrl + '/three_videos_demo', {\n        method: 'POST',\n        body: formData,\n        mode: 'cors',\n      });\n\n      const video = await response.blob();\n      setUiState('success');\n      setFakedRecording(video);\n    } catch (error) {\n      setUiState('errorApi');\n      console.error(error);\n    }\n  };\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'awaitingAudioSource' && <NeutralMessage text=\"Awaiting audio source\" />}\n      {uiState === 'awaitingDestinationVideo' && (\n        <NeutralMessage text=\"Awaiting destination video\" />\n      )}\n      {uiState === 'prompt' && <PromptMessage text=\"Source and Destination ready to be faked\" />}\n      {!uiState.includes('awaiting') && <Button onClick={sendToApi}>Send to API</Button>}\n      {uiState === 'awaitingResult' && <NeutralMessage text=\"Waiting for Api response\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Got faked recording from Api\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Could not fetch from Api\" />}\n      {uiState === 'errorSources' && <ErrorMessage reason=\"Souces are not ready\" />}\n    </div>\n  );\n};\n","export default __webpack_public_path__ + \"static/media/1.6f4d89fa.mp4\";","export default __webpack_public_path__ + \"static/media/2.b65b1142.mp4\";","export default __webpack_public_path__ + \"static/media/3.7bc44234.mp4\";","import { useEffect, useState } from 'react';\nimport { ErrorMessage, NeutralMessage as SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nimport videoSrcStart from './videos/1.mp4';\nimport videoSrcMiddle from './videos/2.mp4';\nimport videoSrcEnd from './videos/3.mp4';\n\nexport const StaticVideoLoader = (): React.ReactElement => {\n  const isAlreadyLoaded = useStore((state) => !!state.staticVideos);\n  const setStaticFiles = useStore((state) => state.setStaticVideos);\n\n  const [uiState, setUiState] = useState<'notLoaded' | 'loading' | 'loaded' | 'error'>(\n    isAlreadyLoaded ? 'loaded' : 'notLoaded',\n  );\n  useEffect(() => {\n    if (isAlreadyLoaded) return;\n\n    const loadVideos = async () => {\n      setUiState('loading');\n\n      try {\n        const start = await (await fetch(videoSrcStart)).blob();\n        const middle = await (await fetch(videoSrcMiddle)).blob();\n        const end = await (await fetch(videoSrcEnd)).blob();\n        setUiState('loaded');\n        setStaticFiles(start, middle, end);\n      } catch (error) {\n        setUiState('error');\n        console.error(error);\n      }\n    };\n\n    loadVideos();\n  }, [isAlreadyLoaded, setStaticFiles]);\n\n  return (\n    <div className=\"StaticFileLoader\">\n      {uiState === 'notLoaded' && <SuccessMessage text=\"Files not loaded\" />}\n      {uiState === 'loading' && <SuccessMessage text=\"Files loading\" />}\n      {uiState === 'loaded' && <SuccessMessage text=\"Files loaded!\" />}\n      {uiState === 'error' && <ErrorMessage reason=\"Files could not load\" />}\n    </div>\n  );\n};\n","import { useEffect } from 'react';\nimport { ErrorMessage, SuccessMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\nexport const VideosReadyDev = (): React.ReactElement => {\n  const maybeStaticVideos = useStore((state) => state.staticVideos);\n  const maybeFakeRecording = useStore((state) => state.fakedRecording);\n  const setPlaybackReadiness = useStore((state) => state.setPlaybackReadiness);\n\n  useEffect(() => {\n    if (!maybeStaticVideos || !maybeFakeRecording) {\n      setPlaybackReadiness(false);\n    } else {\n      setPlaybackReadiness(true);\n    }\n  }, [maybeFakeRecording, maybeStaticVideos, setPlaybackReadiness]);\n\n  if (!maybeStaticVideos) {\n    return <ErrorMessage reason=\"Static videos not loaded\"></ErrorMessage>;\n  }\n  if (!maybeFakeRecording) {\n    return <ErrorMessage reason=\"Fake recording not received\"></ErrorMessage>;\n  }\n\n  return <SuccessMessage text=\"Videos Ready\"></SuccessMessage>;\n};\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { SuccessMessage, ErrorMessage, NeutralMessage } from './ui/Messages';\n\nlet controller = new AbortController();\nlet signal = controller.signal;\n\nfunction fetchStatusHandler(response: Response): Response {\n  if (response.status === 200) {\n    return response;\n  } else {\n    throw new Error(response.statusText);\n  }\n}\n\nexport const ApiUpTest = ({ apiUrl }: { apiUrl: string }): React.ReactElement => {\n  const testApi = useCallback(async () => {\n    try {\n      const response = await fetch(apiUrl + '/three_videos_is_up', {\n        method: 'POST',\n        mode: 'cors',\n        body: new FormData(),\n        signal,\n      }).then(fetchStatusHandler);\n      const file = await response.blob();\n      if (file.size <= 0) {\n        throw new Error('API Failed. Did not get blob successfully');\n      }\n      setUiState('success');\n    } catch (error) {\n      setUiState('errorApi');\n      console.error(error);\n    }\n  }, [apiUrl]);\n\n  useEffect(() => {\n    testApi();\n    const interval = setInterval(async () => {\n      controller.abort();\n      controller = new AbortController();\n      signal = controller.signal;\n      await testApi();\n    }, 10000);\n\n    return () => clearInterval(interval);\n  }, [testApi]);\n\n  const [uiState, setUiState] = useState<'idle' | 'success' | 'errorApi'>('idle');\n\n  return (\n    <div className=\"Api\">\n      {uiState === 'idle' && <NeutralMessage text=\"Api test idle\" />}\n      {uiState === 'success' && <SuccessMessage text=\"Api is Up\" />}\n      {uiState === 'errorApi' && <ErrorMessage reason=\"Api is down\" />}\n    </div>\n  );\n};\n","import { ReactElement } from 'react';\n\nimport './LabelledInput.css';\n\ntype Props = {\n  label: string;\n} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n\nexport const LabelledInput = (props: Props): ReactElement => {\n  return (\n    <div className=\"LabelledInput\">\n      <label className=\"Label\">\n        <span>{props.label} </span>\n        <input className=\"Input\" {...props}>\n          {props.children}\n        </input>\n      </label>\n    </div>\n  );\n};\n","import { ChangeEvent, ReactElement } from 'react';\nimport { LabelledInput } from './ui/LabelledInput';\nimport { store } from './Store';\n\nexport const Config = (): ReactElement => {\n  const onDurationChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const recordingDuration = parseInt(event.target.value, 10);\n\n    store.setState({ config: { ...config, recordingDuration } });\n  };\n\n  const onApiUrlChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const config = store.getState().config;\n    const apiUrl = event.target.value;\n\n    store.setState({ config: { ...config, apiUrl } });\n  };\n  return (\n    <div className=\"Config\">\n      <LabelledInput\n        label=\"Recording Duration:\"\n        name=\"recordingDuration\"\n        type=\"number\"\n        min={0}\n        max={16}\n        defaultValue={store.getState().config.recordingDuration}\n        onChange={onDurationChange}\n      ></LabelledInput>\n\n      <LabelledInput\n        label=\"API Url:\"\n        name=\"apiUrl\"\n        type=\"string\"\n        defaultValue={store.getState().config.apiUrl}\n        onChange={onApiUrlChange}\n      ></LabelledInput>\n    </div>\n  );\n};\n","import React, { ReactElement } from 'react';\nimport { Api } from './Api';\nimport { StaticVideoLoader } from './StaticFileLoader';\n\nimport './DevUi.css';\nimport { VideosReadyDev } from './VideosReadyDev';\nimport { ApiUpTest } from './ApiUpTest';\nimport { Config } from './Config';\nimport { store, useStore } from './Store';\nimport { Button } from './ui/Button';\n\nexport const DevUi = (): ReactElement => {\n  const apiUrl = useStore((state) => state.config.apiUrl);\n  return (\n    <div className=\"DevUi\">\n      <Config />\n      <StaticVideoLoader />\n      <ApiUpTest apiUrl={apiUrl} />\n      <Api apiUrl={apiUrl} />\n      <VideosReadyDev />\n      <Button onClick={store.getState().resetState}>Reset State</Button>\n    </div>\n  );\n};\n","import { useCallback, useEffect, useRef, useState } from 'react';\ntype Props = {\n  start: Blob;\n  middle: Blob;\n  end: Blob;\n};\n\nconst isVideoPlaying = (video: HTMLVideoElement) =>\n  !!(video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2);\n\nexport const SequentialVideos = ({ start, middle, end }: Props): React.ReactElement => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [videos, setVideos] = useState<HTMLVideoElement[]>([]);\n  const [size, setSize] = useState<{ width: number; height: number }>({ width: 0, height: 0 });\n  const [currentVideoIndex, setCurrentVideoIndex] = useState<number>(0);\n\n  useEffect(() => {\n    const effect = async () => {\n      const videos = await Promise.all(\n        [start, middle, end].map((blob, index) => {\n          const isFirst = index === 0;\n          const setSizeCallback = isFirst\n            ? (video: HTMLVideoElement) =>\n                setSize({ width: video.videoWidth, height: video.videoHeight })\n            : () => ({});\n          return loadVideo(blob, setSizeCallback);\n        }),\n      );\n\n      setVideos(videos);\n    };\n\n    effect();\n  }, [end, middle, start]);\n\n  useAnimationFrame(60, () => {\n    const currentVideo = videos[currentVideoIndex];\n    const context = canvasRef.current?.getContext('2d');\n    if (currentVideo === undefined) return;\n    if (context === undefined || context === null) return;\n\n    context.drawImage(currentVideo, 0, 0, size.width, size.height);\n  });\n\n  useEffect(() => {\n    if (videos.length === 0) return;\n    const currentVideo = videos[currentVideoIndex];\n    if (currentVideo === undefined)\n      throw new Error(\n        `currentVideoIndex out of range. Got ${currentVideoIndex}, expected between 0 and ${videos.length}`,\n      );\n    currentVideo.onended = () => setCurrentVideoIndex((currentVideoIndex + 1) % videos.length);\n    if (!isVideoPlaying(currentVideo)) {\n      console.log(`playing video ${currentVideoIndex}`);\n      currentVideo.play();\n    }\n\n    return () => {\n      currentVideo.pause();\n    };\n  }, [currentVideoIndex, videos]);\n\n  return <canvas ref={canvasRef} width={size.width} height={size.height}></canvas>;\n};\n\nasync function loadVideo(videoBlob: Blob, onMetaData: (video: HTMLVideoElement) => void) {\n  return new Promise<HTMLVideoElement>((resolve, reject) => {\n    const video = document.createElement('video');\n    video.src = URL.createObjectURL(videoBlob);\n    video.load();\n    video.onloadeddata = () => resolve(video);\n    video.onerror = (error) => reject(error);\n    video.addEventListener('loadedmetadata', () => onMetaData(video));\n  });\n}\n\nexport const useAnimationFrame = (\n  frameRate: number,\n  callback: (deltaTime: number) => void,\n): void => {\n  const requestRef = useRef<number>();\n  const previousTimeRef = useRef<number>();\n\n  const animate = useCallback(\n    (time: number) => {\n      if (previousTimeRef.current !== undefined) {\n        const deltaTime = time - previousTimeRef.current;\n        callback(deltaTime);\n      }\n      previousTimeRef.current = time;\n    },\n    [callback],\n  );\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      requestRef.current = requestAnimationFrame(animate);\n    }, 1000 / frameRate);\n    return () => {\n      requestRef.current && cancelAnimationFrame(requestRef.current);\n      interval && clearInterval(interval);\n    };\n  }, [animate, frameRate]);\n};\n","import React, { useState } from 'react';\nimport { useStore } from './Store';\nimport { ErrorMessage, PromptMessage } from './ui/Messages';\nimport { Button } from './ui/Button';\n\nexport const Permissions = (): React.ReactElement => {\n  const isUserStreamOn = useStore((state) => !!state.streams);\n  const setStreams = useStore((state) => state.setStreams);\n\n  const [uiState, setUiState] = useState<\n    'prompt' | 'accepted' | 'errorVideo' | 'errorAudio' | 'errorDisconnected'\n  >(isUserStreamOn ? 'accepted' : 'prompt');\n\n  if (uiState === 'accepted') {\n  }\n\n  if (isUserStreamOn && uiState !== 'accepted') {\n    setUiState('accepted');\n  }\n\n  if (!isUserStreamOn && uiState === 'accepted') {\n    setUiState('errorDisconnected');\n  }\n\n  const getStreams = async () => {\n    const audio = await getAudioStream();\n    const video = await getVideoStream();\n\n    if (!audio) {\n      setUiState('errorAudio');\n      return;\n    }\n\n    if (!video) {\n      setUiState('errorVideo');\n      return;\n    }\n\n    setStreams({ audio, video });\n  };\n\n  return (\n    <div className=\"Permissions\">\n      <PromptMessage\n        text={\n          'This is an interactive documentary. The interaction is provided via your microphone and webcam. Please enable this now.'\n        }\n      ></PromptMessage>\n\n      <Button onClick={getStreams}>Enable Webcam & Audio</Button>\n\n      {uiState === 'accepted' && <PromptMessage text={'Devices connected!'}></PromptMessage>}\n      {uiState === 'errorAudio' && <ErrorMessage reason={'Could not get microphone.'} />}\n      {uiState === 'errorVideo' && <ErrorMessage reason={'Could not get webcam.'} />}\n      {uiState === 'errorDisconnected' && <ErrorMessage reason={'Devices disconnected.'} />}\n    </div>\n  );\n};\n\nasync function getAudioStream() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    return stream;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nasync function getVideoStream() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { width: 1280, height: 720, facingMode: 'user' },\n      audio: false,\n    });\n    return stream;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n","import React, { useEffect, useMemo, useState } from 'react';\nimport { Button } from './ui/Button';\nimport { NeutralMessage, PromptMessage } from './ui/Messages';\nimport { useStore } from './Store';\n\ntype Props = {\n  stream: MediaStream;\n  duration: number;\n};\n\nexport const VideoRecorder = ({ stream, duration }: Props): React.ReactElement => {\n  const [timeRemaining, setTimeRemaining] = useState(duration);\n  const [isRecording, setIsRecording] = useState(false);\n\n  const setVideoRecording = useStore((state) => state.setVideoRecording);\n  const videoRecorder = useMemo(() => getVideoRecorder(stream), [stream]);\n\n  const [uiState, setUiState] = useState<'prompt' | 'recording' | 'recorded'>('prompt');\n  useEffect(() => {\n    if (isRecording) return;\n    if (uiState === 'recorded') return;\n\n    setUiState('prompt');\n    setTimeRemaining(duration);\n    setIsRecording(false);\n  }, [isRecording, uiState, stream, duration]);\n\n  useEffect(() => {\n    if (!isRecording) return;\n    const timeout = setTimeout(async () => {\n      if (timeRemaining > 0) {\n        setTimeRemaining(timeRemaining - 1);\n        return;\n      }\n\n      const { videoBlob: blob, videoUrl: url } = await videoRecorder.stop();\n      setUiState('recorded');\n      setIsRecording(false);\n      setVideoRecording({ blob, url });\n    }, 1000);\n\n    return () => clearTimeout(timeout);\n  }, [isRecording, setVideoRecording, timeRemaining, videoRecorder]);\n\n  const recordVideo = () => {\n    setTimeRemaining(duration);\n    setUiState('recording');\n    setIsRecording(true);\n    videoRecorder.start();\n  };\n\n  return (\n    <div className=\"VideoRecorder\">\n      {uiState === 'prompt' && (\n        <PromptMessage\n          text={`Our AI needs to be trained. Please record ${duration} seconds of your webcam`}\n        ></PromptMessage>\n      )}\n      {uiState === 'recording' && (\n        <NeutralMessage text={`Recoding for another: ${timeRemaining}s`}></NeutralMessage>\n      )}\n      {uiState === 'recorded' && <NeutralMessage text={`Trained!`}></NeutralMessage>}\n      {uiState !== 'recording' && <Button onClick={recordVideo}>Record Video</Button>}\n    </div>\n  );\n};\n\ntype VideoRecorderResult = {\n  start: () => void;\n  stop: () => Promise<{\n    videoBlob: Blob;\n    videoUrl: string;\n  }>;\n};\n\nconst getVideoRecorder = (stream: MediaStream): VideoRecorderResult => {\n  const options = { mimeType: 'video/webm; codecs=h264' };\n  const mediaRecorder = new MediaRecorder(stream, options);\n  const videoChunks: Blob[] = [];\n\n  mediaRecorder.addEventListener('dataavailable', (event) => {\n    videoChunks.push(event.data);\n  });\n\n  const start = () => {\n    videoChunks.length = 0;\n    mediaRecorder.start();\n  };\n\n  const stop = () =>\n    new Promise<{ videoBlob: Blob; videoUrl: string }>((resolve) => {\n      mediaRecorder.addEventListener('stop', () => {\n        const videoBlob = new Blob(videoChunks, {\n          type: 'video/webm',\n        });\n        const videoUrl = URL.createObjectURL(videoBlob);\n\n        resolve({ videoBlob, videoUrl });\n      });\n\n      mediaRecorder.stop();\n    });\n\n  return { start, stop };\n};\n","import React, { useEffect, useRef } from 'react';\nimport './VideoStreamPreview.css';\n\ntype Props = {\n  stream: MediaStream;\n};\n\nexport const VideoStreamPreview = ({ stream }: Props): React.ReactElement => {\n  const ref = useRef<HTMLVideoElement | null>(null);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    ref.current.srcObject = stream;\n  }, [stream]);\n\n  return (\n    <div className=\"VideoStreamPreview\">\n      <video autoPlay={true} ref={ref}></video>\n    </div>\n  );\n};\n","import React, { ReactElement } from 'react';\nimport { Permissions } from './Permissions';\nimport { useStore } from './Store';\nimport { VideoRecorder } from './VideoRecorder';\nimport { VideoStreamPreview } from './ui/VideoStreamPreview';\n\nimport './UserUi.css';\n\nexport const UserUi = (): ReactElement => {\n  const isPermissionGranted = useStore((state) => !!state.streams);\n  const stream = useStore((state) => state.streams?.video);\n  const isPlaybackReady = useStore((state) => state.isPlaybackReady);\n  const recordingDuration = useStore((state) => state.config.recordingDuration);\n\n  return (\n    <>\n      {!isPlaybackReady && (\n        <div className=\"UserUi\">\n          {!isPermissionGranted && <Permissions />}\n          {stream !== undefined && (\n            <>\n              <VideoRecorder stream={stream} duration={recordingDuration} />\n              <VideoStreamPreview stream={stream} />\n            </>\n          )}\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport './App.css';\nimport { DevUi } from './DevUi';\nimport { SequentialVideos } from './SequentialVideos';\nimport { useStore } from './Store';\nimport { UserUi } from './UserUi';\n\nfunction App(): React.ReactElement {\n  const staticVideos = useStore((state) => state.staticVideos);\n  const fakedRecording = useStore((state) => state.fakedRecording);\n\n  return (\n    <div className=\"App\">\n      <div className=\"AppContents\">\n        <UserUi />\n        <DevUi />\n        {!!staticVideos && !!fakedRecording && (\n          <SequentialVideos\n            start={staticVideos.start}\n            middle={fakedRecording}\n            end={staticVideos.end}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}